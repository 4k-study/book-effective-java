# Item 18. 상속보다는 컴포지션을 사용하라

(구현)상속을 사용해 코드를 재사용 하는 방법은 좋지만 잘못하면 오류내기 쉬운 상황이 생긴다.

상속은 캡슐화를 깨트리기 때문인데, 어떻게 구현하는지에 따라 하위 클래스가 오동작 할 수 있기 때문이다.

### 상속의 단점

- 상속을 하게 되면 부모 클래스의 자원을 모두 사용하기 때문에 상위 클래스의 잘못을 하위 클래스가 고스란히 받게 된다.
- 상위 클래스를 변경하게 된다면 모든 하위 클래스에 영향이 간다.

### 해결법

- 오버라이딩해서 문제가 생기는 경우 오버라이딩을 하지 않는 방법이 있다. → 이 방법은 해결법이라기보다 회피법에 가깝다고 생각이 든다.
- 컴포지션을 사용한다

# 컴포지션

![image](https://github.com/4k-study/book-effective-java/assets/85796588/7c88bb31-0c02-43b4-b301-60c4ead5486e)

새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하는 방식이다.

- 클래스를 선언한다.
- private 필드로 상속하고자 하는 클래스를 선언한다.
- 재사용 전용  메서드를 만들어준다.
- 상속하여 원하는 메서드를 구현한다.

이렇게 클래스를 한 번만 구현 한다면 어떤 구현체라도 대응할 수 있다.

다음과 같은 방법을 데코레이터 또는 래퍼 클래스라고 한다. 이는 콜백 프레임워크를 제외하면 단점은 없다.

### 결론

상속이 나쁘다는 것은 결코 아니다. 다만 상속을 하려 할때 다음과 같은 질문을 해보자

- 부모 자식간의 관계가 정말 is-a 관계인가?
- 부모 클래스의 API는 문제가 없나?

잘못된 상속의 예시를 보고 싶다면 Vector - Stack, Hashtable - Properties 코드를 찾아보면 된다. 

### 마무리

객체지향의 장점인 상속이 좋은 객체지향의 예시인 캡슐화와 낮은 의존도를 깨트리다니 재밌다.
