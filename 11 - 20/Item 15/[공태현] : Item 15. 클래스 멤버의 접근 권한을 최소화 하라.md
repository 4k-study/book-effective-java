## 캡슐화

<aside>
💡 내부 구현을 완벽히 숨겨 구현과 API를 분리하여 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 관여하지 않는 것

</aside>

### 정보 은닉의 장점

- 시스템 개발 속도 증가
- 시스템 관리 비용 감소
- 성능 최적화
    - 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있음
- 재사용성 증가
- 큰 시스템 제작 난이도 감소

### 접근 제한자

- Java에서 정보은닉에 활용할 수 있는 방법

### 캡슐화 원칙

- 모든 클래스와 멤버의 접근성을 가능한 한 좁힌다.
    - 가장 낮은 수준을 부여해야 한다.
- **클래스**
    - 클래스는 `public`, `package-private` 접근제한자만 사용할 수 있다.
    - 애플리케이션 전역적으로 사용해야 된다면 `public` 접근제한자를, 패키지 안에서만 사용할 수 있는 클래스라면 `package-private` 접근자한자를 지정한다.
    - 한 클래스에서만 사용하는 `package-private` 톱레벨 클래스나 인터페이스는 이를 사용하는 클래스 안에 `private static`으로 중접시킬 수 있다.
    - `public`일 필요가 없는 클래스의 접근 수준을 `package-private` 톱레벨 클래스로 좁힌다.
- ******멤버******
    - 우선 모든 멤버는 `private`으로 만든다. 그리고 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 `package-private`으로 풀어주자.
    - `public` 클래스에서는 멤버의 접근 수준을 `package-private`에서 `protected`로 바꾸는 순간 그 멤버에 접근할 수 있는 대상 범위가 넓어진다. 따라서 `protected` 멤버의 수는 적을수록 좋다.
    - 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다.
        - 리스코프 치환원칙으로 인해
    - `public` 클래스의 인스턴스 필드는 되도록 `public`이 아니어야 한다.
        - `public`으로 두면 객체가 자신의 필드 값을 제한할 힘이 사라진다.
        - 스레드 세이프 하지 않다.
    - 클래스가 표현하는 추상 개념을 완성하는 데 필요한 구성요소로써의 상수라면 `public static final` 필드로 사용해도 된다.
    - 길이가 0이 아닌 배열은 변경 가능하기 때문에 주의해야 한다. 따라서 클래스에서 `public static final` 필드에 배열을 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.
        - 필드 접근제한자를 `private static final`로 만들고 `getter`를 통해 가져올 수 있게 하더라도 해당 필드를 불변 리스트로 하거나 배열을 복사한 새로운 배열을 반환해야 한다.

### 핵심

핵심은 클래스, 필드, 메소드 모두 외부와의 접근을 최소화하고 가능한 접근성을 가장 좁게 설정해야 한다.
