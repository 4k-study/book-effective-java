## 상속을 고려한 설계와 문서화

### 1. 상********************************************************************************************************************************************************************************************************************************************************속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.********************************************************************************************************************************************************************************************************************************************************

```java
public class A {
	public void methodA() {
		// ...
		methodB();
		// ...
	}

	protected void methodB() {...};
}
```

예를 들어, 위와 같이 클래스 `A`의 공개된 메소드인 `methodA()`에서 재정의 가능한 메소드인 `methodB()`를 재사용하고 있다. 이런 경우 `methodB()`를 호출하는 메서드의 API 설명에 적시해야 한다. 추가적으로 어떤 순서로 호출하고, 각각의 호출 결과가 이어지는 처리에 어떻게 영향을 주는지도 명시해야 한다. 왜냐하면, `methodB()`를 재정의한다면, `methodA()`의 코드에 큰 영향을 끼칠 수 있기 때문이다. 

이는 캡슐화를 깨뜨리는 것이지만, 클래스를 안전하게 상속할 수 있도록 하려면 어쩔 수 없다.

### 2. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.

```java
public class A {
	public void methodA() {
		// ...
		B 로직 
		// ...
}

-----> 

public class A {
	public void methodA() {
		// ...
		methodB();
		// ...
	}

	// hook
	protected void methodB() { 
		B 로직 
	}
}
```

위 클래스 `A`에서 `methodA()`에 내부적으로 `B로직`이 호출되고 있다. 여기서 `B로직`을 재정의 가능하도록 `protected` 메소드인 `methodB()`로 추출한다면, 클래스 `A`를 상속한 뒤, `methodB()`를 재정의해 준다면, `methodA()`의 연산이 더 효율적으로 변경될 수도 있다. 

이렇게 뽑아낸 `methodB()`가 훅으로, 이를 잘 선별해서 메소드로 추출한다면 더 좋은 상속 클래스를 만들 수 있다. (어떤 메소드를 뽑아야 할지는 알아서 하자. 책에서는 직접 하위 클래스를 만들어보는 것이 유일하다고 설명한다.)

### 3. 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.

```java
public class A {
    public A() {
        methodA();
    }

    protected void methodA() {
        System.out.println("call methodA by A");
    }
}

public class B extends A {

    private String name;

    public B(String name) {
        this.name = name;
        methodA();
    }

    @Override
    protected void methodA() {
        System.out.println("name length is : " + this.name.length());
    }
}
```

클래스 `A`와 이를 상속한 `B`가 있다. 이때, `A` 생성자 호출 시 재정의 가능한 `methodA()`를 호출하고, `B`는 `methodA()`를 재정의 하였다. 근데, 재정의한 `methodA`에서 `B`에만 존재하는 필드 `name`에 접근한다.

```java
public static void main(String[] args) {
    B b = new B("Kong");
}
```

그리고 `B`의 생성자를 호출하면 다음과 같이 `NullPointerExeption`이 발생한다.

![image](https://github.com/4k-study/book-effective-java/assets/68289543/25d00843-e63f-4011-aee0-315fad8f7bff)

왜냐하면, `B`의 생성자를 호출하면, `A`의 생성자가 먼저 호출된다. 그러면 `methodA()`가 호출되는데, 이 `methodA()`는 `B`에 재정의 되어있다. 재정의된 메소드를 보면 `B`의 필드인 `name`에 접근하고 있는데, `A`의 생성자가 호출될 당시에는 `name`은 초기화되지 않았기 때문에 `null`값이 들어간다. 이때 `null.length()`를 호출하려고 하니 `NullPointerException`이 발생하는 것이다. 

→ `clone()`과 `readObject()` 모두 새로운 객체를 생성할 때 사용하는 메소드이기 때문에 마찬가지로 재정의 가능 메서드를 호출해서는 안된다.

### 상속용 클래스가 아니면 상속을 금지하자

1. 클래스를 `final`로 선언하자
2. 생성자를 `private`으로 막아두고 정적 팩터리 메소드를 만들어주자.

### 상속을 꼭 해야만 한다면?

- 재정의 메소드를 클래스 내부에서 사용하지 말자
    - 메소드를 재정의해도 다른 메소드에 영향을 주지 않음
