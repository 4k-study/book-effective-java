# Item 11. equals를 재정의하려거든 hashCode도 재정의하라

equals를 재정의한 클래스는 반드시 hashCode도 재정의 해야한다. 그렇지 않는 경우 hashCode 일반 규약을 어기고, hash를 사용할때 문제가 발생한다.

hashCode 메서드의 일반 규약

- equals 비교에 사용된 정보가 변경되지 않았다면, hashCode 메서드를 몇 번 호출해도 같은 값을 반환해야 한다. 단, 어플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
- equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
- 서로 다른 인스턴스는 다른 hashCode를 반환한다. (두 인스턴스의 hashCode는 같을 수 있다.)

equals 메서드를 사용해 다른 인스턴스를 논리적으로 같다고 했는데, hashCode가 다르면 이 둘은 전혀 다르다고 판단된다. 이 부분이 문제가 된다.

hashCode 메서드의 규약을 지켜가면서 재정의 하려면 어떻게 해야할까?

1. int result를 선언한 후 c로 초기화 한다.
2. 해당 객체의 핵심 필드 각각에 다음 작업을 수행한다.
    1. 기본 타입 필드라면 박싱 클래스의 hashCode 를 호출한다.
    2. 참조면서 equals 메서드가 재귀적으로 호출해 비교한다면, hashCode또한 재귀적으로 호출한다.
    3. 필드가 배열이라면 핵심 원소 각각을 별도 필드처럼 다룬다. 원소가 없다면 상수를 추천한다.
    4. 위의 해시코드들로 result를 갱신한다.
3. result를 반환한다

hashCode를 구현했다면 이 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환하는지 단위테스트를 작성해 확인하는 것이 좋다. 외부 프레임워크나 IDE의 도움을 받았다면 작성하지 않아도 좋다.

보통 해시코드를 구할때 곱하는 상수로 31을 사용하는데 31이 2^5 - 1 이면서 소수여서 그렇다. 별다른 이유나 증명된 사실은 없다.

### 결론

equals를 재정의할 때 hashCode도 재정의하자. hashCode도 일반 규약도 따라야 하며, equals에서 사용한 필드를 전부 사용하여 구현하는게 좋다. (AutoValue등 자동화 기능을 사용하라.)

hashCode 생성 규칙은 클라이언트나 사용자에게 알려줄 필요가 없다.
