# Item 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라

* 가변인수 : 메서드에서 인수를 받을 때 인수의 개수를 임의로 받을 수 있도록 도와주는 기능

```java
//메인메서드에 쓰이는게 가변인수이다.
public static void main(String[] args) { ... }
public void test1(String ... str) { ... }
public void <E> test2(E ... elements) {...}
```

가변인수는 다른 인자와 함께 사용할때 제일 마지막에 사용해야 하며, 타입이 같은경우 오버라이딩이 안되니 오버라이딩을 하지 않는게 좋다.

본론으로 돌아와서 제네릭과 가변인수를 함께 사용하면 신중해야 한다.

매개변수 타입의 인수가 다른 타입을 참조하게 되는 경우 자동으로 형변환을 하게되어 힙오염과 ClassCastException을 야기하기 때문이다. 즉 타입 안정성을 위한 제네릭이 안정성을 깨트리는 상황이 생긴다.

제네릭 배열은 생성이 불가능하지만, 제네릭 가변인수는 허용하는 이유는 뭘까?

→ 유용함이 매우 커서이다. 실제로 Arrays.asList(T … a) 이런 메서드는 타입 안전성까지 보장한다.

동시에 저런 메서드를 사용할때 클라이언트 코드마다 `@SupressWarnings` 어노테이션을 달아야 하는 불편함은 `@SafeVarargs` 를 달아 안정성을 보장할 수 있다.

`@SafeVarargs` 어노테이션은 매우 신중하게 사용해야 하는데, 가변인수 배열에 값을 추가하거나, 외부로 노출하지 않는다면 안전하다고 보면 된다.

단 배열을 그대로 반환하면 컴파일러는 반환타입을 모르기 때문에 Object 배열을 반환해 힙오염과 에러가 반환된다.

이 문제는 가변인수가 배열을 사용하기 때문인데, 제네릭을 사용하면 문제를 우회(?)할 수 있다.

```java
public void <T> List<T> listTest(List<List<? extends T>> lists) { ... }
```

이렇게 메서드를 작성하면 배열이 아닌 List를 반환하기 때문에 배열을 사용하지 않는다.

### 마무리

왠만하면 가변인수와 제네릭을 같이 사용하지 말자.

타입 안정성을 깊게 생각해보고 어노테이션으로 경고 메시지를 막을 수 있고, 배열 대신 제네릭을 사용해도 좋다.
