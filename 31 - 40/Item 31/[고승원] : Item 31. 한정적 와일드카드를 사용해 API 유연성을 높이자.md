# Item 31. 한정적 와일드카드를 사용해 API 유연성을 높이자

제네릭을 사용한 원소로 갖는 매개변수화 타입은 불공변이다.

불공변이 항상 옳을까? 그렇지 않다. 유연한 방식이 필요할때도 있는데, 이는 한정적 와일드카드를 사용해 해결한다.

예를들어

```java
Stack<Object> objectStack = new Stack<>();
Itarable<String> strings = ...;

// String은 Object의 하위 클래스지만 에러가 난다.
objectStack.pushAll(strings);
```

이런 상황은 와일드카드가 해결해준다.

```java
public void pushAll(Iterable<? extends E> input) {
	...
} 
```

이렇게 메서드를 작성하면, E를 포함한 하위 타입을 커버할 수 있다.

**주의할점은 메서드 반환 타입에 한정적 와일드카드를 사용하면 안된다는 점이다.**

→ 클라이언트 코드에 영향을 주기 때문.

### 한정적 와일드카드 종류

- <? extends E> : E를 포함한 하위타입 (producer)
- <? super E> : E를 포함한 상위 타입 (consumer)

메서드를 선언할 때 와일드카드와 타입 매개변수중 어떤걸 사용할지 고민이 될때가 있을 것이다.

→ 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드 카드로 대체하라. 그렇지 않으면 컴파일 오류가 난다. (내부 타입 매개변수로 해결 가능)

### 마무리

제네릭은 타입안정성을 충분히 챙겨주는 고마운 존재이다. 하지만, 제네릭이 만든 불공변성이 유연성을 해치기도 하는데, 이는 와일드카드를 사용해 유연하게 만들어줄 수 있다. 반드시 유연해야 할 때만 사용하자.
