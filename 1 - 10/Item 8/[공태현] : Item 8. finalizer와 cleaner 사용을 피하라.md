### finalizer란?

<aside>
💡 GC에 의해 객체가 소멸되기 전에 호출되는 메소드

</aside>

- 예측할 수 없고, 상황에 따라 위험할 수 있다.
- 오동작, 낮은 성능, 이식성 문제의 원인이 되기도 한다.
- 자바 9에서는 deprecated 되었다.

→ 사용하지 말자

### Cleaner란?

<aside>
💡 Java 9에서 finalizer가 deprecated 되고 그 대안으로 추가된 클래스

</aside>

- 여전히 불필요함

## 사용하면 안되는 이유

- finalizer와 cleaner는 즉시 수행된다는 보장이 없다.
    - 파일 닫기를 finalizer와 cleaner에 맡기면 파일이 언제 닫힐지 모르기 때문에 문제가 발생할 수 있다.
- finalizer와 cleaner를 얼마나 신속히 수행할지는 전적으로 GC 알고리즘에 달려있다.
- 자바 언어 명세는 finalizer나 cleaner의 수행 시점뿐 아니라 수행 여부조차 보장하지 않는다.
- 상태를 영구적으로 수정하는 작업에서는 절대 의존하면 안된다.
    - 데이터베이스의 영구 락 해제
- `System.gc()` 메소드를 호출해도 finalizer와 cleaner가 실행된다는 보장이 없다.
- finalizer 동작 중 발생한 예외는 무시되며 처리할 작업이 남았더라도 종료된다.
- GC의 효율을 떨어뜨리기 때문에 성능적으로도 문제가 된다.
- 심각한 보안 문제를 일으킬 수 있다.
    - final 클래스로 만들거나 아무것도 하지 않는 finalize 메소드를 오버라이딩 하면 된다.

## 대안

- 파일이나 스레드 등 종료해야 할 자원을 담고 있는 객체의 클래스에서는 `AutoCloseable`을 구현해주고 인스턴스를 다 쓰고 나면 `close()` 메소드를 호출한다.
    - 예외가 발생해도 제대로 종료되도록 `try-with-resources`를 사용해야 한다.

## finalizer와 cleaner의 쓰임

- 자원의 소유자가 `close()` 메소드를 호출하지 않은 것에 대한 안정망 역할
    - 클라이언트가 하지 않은 자원 회수를 늦게라도 해준다.
- 네이티브 피어와 연결된 객체
    - 네이티브 피어: 자바 개체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체
    - 네이티브 피어는 자바 객체가 아니기 때문에 GC가 존재를 알지 못한다. (GC가 회수 못함)
    - → 이것도 `close()`를 사용하는게 나음
