## equals란?

<aside>
💡 equals() 메서드는 Object 객체에 정의된 메서드로 기본적으로 객체의 주소를 비교한다.

</aside>

```java
Data d1 = new Data("Kong", 10);
Data d2 = new Data("Kong", 10);

System.out.println(d2.equals(d1));
```

따라서 위 코드는 `false`를 반환한다.

## equals를 재정의 하지 않아야될 상황

- **각 인스턴스가 본질적으로 고유하다.**
    - 값을 표현하는 객체가 아닌 동작하는 객체
- **인스턴스 간 논리적으로 같은지 확인할 필요가 없는 경우**
- **상위 클래스에서 재정의한 equals()가 하위 클래스에도 들어맞는 경우**
- **클래스가 private이거나 패키지가 private이고 equals 메서드를 호출할 일이 없는 경우**

## equals를 재정의해야 하는 경우

→ 객체가 논리적 동치성을 확인해야 하는데, 상위 클래스의 `equals()`가 논리적 동치성을 비교하도록 재정의 되지 않았을 경우 (즉, 객체의 값을 비교해야 하는 경우)

## equals 메서드의 재정의 규약

- 반사성: `x.equals(x)`는 `true`
- 대칭성: `x.equals(y)`가 `true`이면 `y.equals(x)`는 `true`이다.
- 추이성: `x.euqals(y)`가 `true`이고, `y.equals(z)`가 `true`이면 `x.equals(z)`도 `true`이다.
- 일관성: `x.equals(y)`를 반복해서 호출하면 항상 `true`거나, 항상 `false`여야 한다.
- null 아님: `null`이 아닌 모든 참조 값 `x`에 대해, `x.equals(null)`은 `false`이다.

### 반사성

- 객체는 자기 자신과 같아야 함

### 대칭성

- 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.

### 추이성

- 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다.
- 상속 관계를 `equals()`로 비교할 때 추이성을 어길 수 있다.
    - 하위타입1.equals(상위타입)가 true, 상위타입.equals(하위타입2)가 true일 때, 하위타입1.equals(하위타입2)가 false일 수 있음
- 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
    - 상속 대신 컴포지션을 사용하라
- 상속 관계에서 `equals()` 메소드를 사용할 때 주의하자
    - `Collection`에서 다형성을 활용할 때도 주의하자

### 일관성

- 두 객체가 같다면 앞으로도 영원히 같아야 한다.
- 불변 객체끼리의 `equals()` 메소드의 결과는 항상 동일한 결과를 반환해야 한다.

### null 아님

- 모든 객체가 `null`과 같지 않아야 한다.
- 일반적으로 `equals()` 메소드를 재정의할 때 인수로 들어온 객체의 타입을 확인하기 위해 `instance of`를 사용하는데 `instance of`는 첫 번째 인수가 `null`이면 `false`를 반환한다. → 묵시적 `null` 체크

## 양질의 `equals` 메서드 구현법

- ********`==` 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.**
    - 성능 최적화용
    - `(if o == this) return true`
- `**instance of` 연산자로 입력이 올바른 타입인지 확인한다.**
    - 보통 자신의 타입과 비교한다.
    - 인터페이스를 구현한 클래스끼리 비교하는 경우 `instance of`의 두 번째 인수가 인터페이스가 될 수 있다.
- **입력을 올바른 타입으로 형변환 해야한다.**
    - `instance of`를 잘 사용했다면 항상 성공한다.
- **입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사한다.**
    - 모든 필드가 일치하면 `true`, 하나라도 다르면 `false`

## 추가

- `float`과 `double`을 제외한 기본 타입 필드는 `==` 연산자로 비교하고 참조 타입 필드는 각각의 `equals()` 메서도드로, `float`과 `double` 필드는 각각 정적 메서드인 `Float.compare()`, `Double.compare()`로 비교한다.
    - `Float.NaN`, `-0.0f` 등을 다뤄야 하기 때문
    - `Float.equals()`는 오토박싱 때문에 성능이 안좋을 수 있음
- `null`을 정상값으로 취급하는 참조 타입인 경우 `Object.equals()`를 사용하여 `NullPointerException`을 방지하자
- 비교하기가 복잡한 필드를 가진 클래스인 경우 필드의 표준형을 저장해둔 후 표준형끼리 비교하면 훨씬 경제적이다.
- 다를 가능성이 더 크거나 비교하는 비용이 싼 필드를 먼저 비교하자
- `equals()`를 재정의할 땐 반드시 `hashCode()`도 재정의하자
- 인자는 항상 `Object` 타입으로 두자
